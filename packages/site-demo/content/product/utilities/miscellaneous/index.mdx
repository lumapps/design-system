import uniqueId from 'lodash/uniqueId';
import { mdiEarth } from '@lumx/icons';
import { Message, Chip, Icon } from '@lumx/react';
import { startViewTransition } from '@lumx/react/utils';

# Miscellaneous utilities

The `@lumx/react/utils` module contains utilities like React hooks, functions and component that provide re-usable logic.

## ClickAwayProvider

A React context provider that build a tree (both DOM and React) of elements that are considered "within" the context even if children are rendered as in a React portal. User clicks outside this context will trigger to provided `callback`.

```tsx
<ClickAwayProvider callback={close} childrenRefs={useRef([cardRef])}>
    <article ref={cardRef}>
        <p>Click outside this card to close it.</p>
        <Dropdown>...</Dropdown>
    </article>
</ClickAwayProvider>
```

<Message kind="info">
    In this example, clicking outside the card (referenced by <code>cardRef</code>) will trigger the <code>close</code> callback. Clicks in children DOM nodes of the card or children of nested "click away" contexts (here the dropdown) are all considered as "in" the the context and won't trigger the callback.
</Message>

This is used to provide correct "click away" behavior on nested `Dialog` or `Dropdown` even though they are not nested in the DOM tree.

## Portal

The `Portal` component renders its children into a new subtree outside of the current DOM hierarchy. By default, it renders to `document.body`. This is useful for components that need to appear above everything else, like `Dialog` or `Tooltip`.

You can use the `enabled` prop to conditionally render the portal.

## PortalProvider

The `PortalProvider` component allows you to specify a different container for all `Portal` components within its subtree.

The `PortalProvider` takes a `value` prop, which is a function that returns an object with a `container` (a DOM element or fragment). The `Portal` component, when used within a `PortalProvider`, will render its children into that container.

This is useful for scenarios where you need to render components in a specific part of your application's layout instead of `document.body`.

```tsx
import { Button } from '@lumx/react';
import { Portal, PortalProvider } from '@lumx/react/utils';
import { useEffect } from 'react';

function initPortal() {
    const container = document.createElement('div');
    document.body.appendChild(container);
    return { container, teardown: () => container.remove() };
}

const MyComponent = () => (
    <PortalProvider value={initPortal}>
        <p>The button below will be rendered inside a custom div appended to the document body.</p>
        <Portal>
            <Button>My button is in the portal</Button>
        </Portal>
    </PortalProvider>
);
```

<Message kind="info">
    In this example, `initPortal` initializes a container div for all portals defined inside the children content
</Message>

## Disabled state context

The `DisabledStateProvider` component allows you to set the disabled state of all components nested.

```tsx
import { Button, TextField, Checkbox } from '@lumx/react';
import { DisabledStateProvider } from '@lumx/react/utils';

const MyComponent = () => (
  <DisabledStateProvider state="disabled">
    <Button>Button</Button>
    <TextField />
    <Checkbox />
  </DisabledStateProvider>
)
```

<Message kind="info">
    In this example, the button, text field and checkbox in the context will all get disabled.
</Message>

To get your custom component to handle this disable state context, you can use the `useDisabledStateContext()` hook
(from the same `@lumx/react/utils` module).


## startViewTransition

A wrapper around <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition">`document.startViewTransition()`</a> that transitions changes between two UI states.

<Message kind="warning">
    If this API is not supported by the browser (check <a href="https://caniuse.com/mdn-api_document_startviewtransition">for compatibility</a>) or if the user has <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion">reduced motion</a> enabled, the changes will occur without triggering a view transition.
</Message>


### Simple cross-fade transition

A view transition can be triggered by calling `startViewTransition` with a React UI update callback. Automatically, the browser will animate a cross-fade of the state before and after the UI change.

**Example of a simple cross-fade between two UI states:**

<DemoBlock alwaysShowCode orientation="horizontal">
    {function App() {
        const [show, setShow] = React.useState(false);
        const toggle = () => {
            startViewTransition(() => setShow((wasShown) => !wasShown));
        };
        return (
            <Chip onClick={toggle}>
                {!show ? 'Click me to change my label' : 'Click again to go back to the previous label'}
            </Chip>
        );
    }}
</DemoBlock>

### Grouped elements transition

To transition individual elements between the before and after state, groups of elements should be provided.

A group is identified with a name and references an old element (existing at the start) and a new element (existing at the end of the transition).

The animation for each group can be customized with CSS `::view-transition-*` pseudo-elements ([see MDN documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/::view-transition-old))

**Example of transition between element groups:**

<DemoBlock alwaysShowCode orientation="horizontal">
    {function App() {
        const [isBefore, setIsBefore] = React.useState(true);
        const beforeRef = React.useRef(null);
        const afterRef = React.useRef(null);
        const chipRef = React.useRef(null);
        const toggle = () => {
            // Transition between the before and after icons
            const iconBeforeAfterGroup = {
                name: uniqueId('icon-transition'),
                old: isBefore ? beforeRef : afterRef,
                new: isBefore ? afterRef : beforeRef,
            };
            // Transition the label with itself
            const chipLabel = chipRef.current?.querySelector('.lumx-chip__label');
            const labelGroup = {
                name: uniqueId('label'),
                old: chipLabel,
                new: chipLabel,
            };
            startViewTransition(() => setIsBefore(!isBefore), {
                groups: [iconBeforeAfterGroup, labelGroup],
            });
        };
        return (
            <Chip
                ref={chipRef}
                before={isBefore && <Icon ref={beforeRef} icon={mdiEarth} />}
                onClick={toggle}
                after={!isBefore && <Icon ref={afterRef} icon={mdiEarth} />}
            >
                Click to move the icon before/after
            </Chip>
        );
    }}
</DemoBlock>
